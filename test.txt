#include <SFML/Window.hpp>
#include <glad/glad.h>
#include <GL/glext.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <iostream>
using namespace std;


// Helper: Load shader source from file
// Load SPIR-V binary from file
std::vector<char> loadSPIRV(const std::string& path) {
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        throw std::runtime_error("Failed to read SPIR-V binary");
    }
    return buffer;
}

GLuint createShaderFromSPIRV(GLenum shaderType, const std::string& spvPath) {
    std::vector<char> spirv = loadSPIRV(spvPath);

    GLuint shader = glCreateShader(shaderType);
    glShaderBinary(1, &shader, GL_SHADER_BINARY_FORMAT_SPIR_V, spirv.data(), (GLsizei)spirv.size());
    glSpecializeShader(shader, "main", 0, nullptr, nullptr); // "main" entry point

    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
    if (status != GL_TRUE) {
        char log[512];
        glGetShaderInfoLog(shader, 512, nullptr, log);
        std::cerr << "SPIR-V Shader compilation error: " << log << std::endl;
        return 0;
    }
    return shader;
}


// Helper: Link program and check for errors
GLuint createProgram(GLuint vertShader, GLuint fragShader) {
    GLuint program = glCreateProgram();
    glAttachShader(program, vertShader);
    glAttachShader(program, fragShader);
    glLinkProgram(program);

    GLint status;
    glGetProgramiv(program, GL_LINK_STATUS, &status);
    if (status != GL_TRUE) {
        char buffer[512];
        glGetProgramInfoLog(program, 512, nullptr, buffer);
        std::cerr << "Program link error: " << buffer << std::endl;
        glDeleteProgram(program);
        return 0;
    }
    return program;
}

int main() {
    // Request OpenGL 4.6 core context with SFML
    sf::ContextSettings settings;
    settings.majorVersion = 4;
    settings.minorVersion = 6;
    settings.attributeFlags = sf::ContextSettings::Core;

    sf::Window window(sf::VideoMode(800, 600), "OpenGL 4.6 + SFML", sf::Style::Default, settings);
    gladLoadGL();
    // Load shaders

    GLuint vertShader = createShaderFromSPIRV(GL_VERTEX_SHADER, "assets/shaders/shader.vert.spv");
    GLuint fragShader = createShaderFromSPIRV(GL_FRAGMENT_SHADER, "assets/shaders/shader.frag.spv");
    if (vertShader == 0 || fragShader == 0) return -1;

    GLuint shaderProgram = createProgram(vertShader, fragShader);
    glDeleteShader(vertShader);
    glDeleteShader(fragShader);
    if (shaderProgram == 0) return -1;

    // Vertex data for a triangle
    float vertices[] = {
         0.0f,  0.5f, 0.0f,  // top
         0.5f, -0.5f, 0.0f,  // right
        -0.5f, -0.5f, 0.0f   // left
    };

    // Setup VAO and VBO
    GLuint VAO, VBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // vertex attribute: layout(location = 0) in vec3 aPos;
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    // Enable depth test (optional here)
    glEnable(GL_DEPTH_TEST);

    // Main loop
    bool running = true;
    while (running) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                running = false;
        }

        // Clear screen
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Use shader program
        glUseProgram(shaderProgram);

        
        glm::mat4 model = glm::rotate(glm::mat4(1.0f), (float)clock()/CLOCKS_PER_SEC*float(M_PI)/5, glm::vec3(0, 1, 0));
        glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, -2));
        glm::mat4 proj = glm::perspective(glm::radians(45.0f), 800.f / 600.f, 0.1f, 100.0f);

        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "model"), 1, GL_FALSE, &model[0][0]);
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view"), 1, GL_FALSE, &view[0][0]);
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection"), 1, GL_FALSE, &proj[0][0]);

        // Draw triangle
        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLES, 0, 3);
        glBindVertexArray(0);

        window.display();
    }

    // Cleanup
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteProgram(shaderProgram);

    window.close();
    return 0;
}
